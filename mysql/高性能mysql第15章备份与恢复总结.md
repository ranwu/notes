获取文件系统的快照，需要用到LVM。

先澄清几核心术语。热备份、暖备份和冷备份。

例如：“热备份”不需要任何的服务停机时间。

还原和恢复。还原意味着从备份文件中获取数据，可以加载这些文件到MySQL里，也可以将这些文件放置到MySQL期望的路径中。

恢复指的是当某些异常发生后对一个系统或其部分的拯救。包括从备份中还原数据，以及使服务器完全恢复功能的所有必要步骤，例如重启MySQL，改变配置和**预热服务器**的缓存等。

在很多人的概念中，恢复仅意味着修复崩溃后损坏的表。这与恢复一个完整的服务器是不同的。存储引擎的崩溃恢复要求数据和日志文件一致。要求确保数据文件中只包含已经提交的事务所做的续改，恢复操作会将日志中还没有应用到数据文件的事务重新执行。

---

### 定义恢复需求

还需要一个强大的恢复系统。

让备份系统平滑工作比构造良好的恢复过程和工具更容易。原因如下：

- 备份在先。只有已经做了备份才可能恢复，因此在构建系统时，注意力自然会集中到备份上。
- 备份由脚本和任务自动完成。要经常调优备份过程。
- 备份是日常任务，但恢复常常发生在危急情形下。
- 培养多个人来备份。

`mysqldump` 加上 `-d` 选项后备份变得像闪电一样。为什么？因为使用`-d`选项将不会备份数据！既要关注备份也要关注恢复。

规划备份和恢复策略时，有两个重要的需求可以帮助思考：

1. 恢复点目标（RPO）
2. 恢复时间目标（RTO）

作用是定义了可以容忍丢失多少数据，以及需要等待多久将数据恢复。

>备份误区：“复制就是备份”。复制不是备份，使用RAID阵列也不是备份。为什么这么说呢？如果意外地在生产服务器上执行了DROP DATABASE，它们是否可以帮你恢复所有的数据？RAID和复制连这个简单的测试都没法通过。所以它们不是备份，也不是备份的替代品。只有备份才能满足备份的要求。

建议：

- 对于大数据库来说，物理备份是必须的：逻辑备份太慢并受到资源限制，从逻辑备份中恢复需要很长的时间。
- 保留多个备份集。
- 定期从逻辑备份（或者物理备份）中抽取数据进行恢复测试。
- 保存二进制日志以用于基于故障时间点的恢复。
- 完全不借助备份工具本身来监控备份和备份的过程。需要另外验证备份是否正常。
- 通过演练整个恢复过程来测试备份和恢复。目的是测算恢复所需要的资源（CPU、磁盘空间、实际时间，以及网络带宽等）。

基于故障时间点的恢复，可能要建立**日常备份**并保证所需要的**二进制日志**是有效的。这样才能从备份中还原，并通过重放二进制日志来恢复到想要的时间点。

---

### 在线备份还是离线备份

离线备份的风险最小。因为如果关闭了MySQL，就根本不用关心InnoDB缓冲池中的脏页或其他缓存。也不需要担心数据在尝试备份的过程被修改。

停机备份的代价更昂贵。怎么才能让这一损失降低到最低？

在众多的备份方法中，一个最大的问题就是它们会使用FLUSH TABLES WITH READ LOCK操作。这会导致MySQL关闭并锁住所有的表，将MyISAM的数据文件刷新到磁盘上（但InnoDB不是这样的！），并且刷新查询缓存。但这样做会需要非常长的时间来完成。如果全局读锁要等待一个长时间运行的语句完成，或有许多表，那么时间会更长。除非锁被释放，否则就不能在服务器上更改任何数据，一切都会被阻塞和积压。FLUSH TABLES WITH READ LOCK不像关闭服务器的代价那么高，因为大部分缓存仍然在内存中，并且服务器一直是“预热的”，也就是没有断电。

避免使用FLUSH TABLE WITH READ LOCK的最好的方法是只使用InnoDB表。

在规划备份时，有一些与性能相关的因素需要考虑。

*锁时间*
需要持有锁多长时间？我的理解就是当数据库中的这些表被锁住的时候，我们就可以使用热备份。

*备份时间*

复制备份到目的地需要多久？这个要怎么计算？

*备份负载*

在复制备份到目的地时对服务器性能的影响有多少？

*恢复时间*

把备份镜像从存储位置复制到MySQL服务器，重放二进制日志等，需要多久？

最大的权衡是备份时间与备份负载。可以牺牲其一以增强另外一个。例如提高备份的优先级，代价是降低服务器性能，服务器性能降低了就有可能导致客户访问网站变慢。

利用负载的特性来设计备份。

---

### 逻辑备份还是物理备份

两种主要方法来备份MySQL数据：逻辑备份（也叫“导出”）和直接复制原始文件的物理备份。逻辑备份将数据包含在一种MySQL能偶解析的格式中，比如后缀名为SQL的文件。

*逻辑备份的优点：*

- 逻辑备份是可以用编辑器或像grep和sed之类的命令查看和操作的普通文件。当需要恢复数据或只想查看数据但不恢复时，这都非常有帮助。
- 恢复非常简单。可以通过管道把她们输入到mysql，或者使用mysqlimport。
- 可以通过网络来备份和恢复。
- 可以在类似Amazon RDS这样不能访问底层文件系统的系统中使用。
- 非常灵活，用mysqldump可以用WHERE子句来限制需要备份哪些行。
- 与存储引擎无关。为什么呢？因为是从MySQL服务器中提取数据而生成，所以消除了底层数据存储和不同。因此，可以从InnoDB表中备份，然后只需极小的工作量就可以还原到MyISAM表中（WHAT‘S MyISAM？）
- 有助于避免数据损坏。如果磁盘出现故障，但是MySQL的数据还存在内存当中，且不能得到一个正常的备份时，有时可以获得一个可以信赖的逻辑备份。恩，也就是说，逻辑备份可以和磁盘无关联，即使磁盘有问题，也可以从内存中再备份。

*逻辑备份的缺点*

- 由于需要由数据库服务器来完成逻辑备份的工作，因此要使用更多的CPU周期。也就是耗费资源了。
- 逻辑备份在某些场景下比数据库文件本身还大。
- 无法保证导出后再还原出来的一定是同样的数据。
- 从逻辑备份中还原需要MySQL加载和解释语句，转化为存储格式，并重建索引，所以这一切会很慢。（解决的方案是使用Percona Server中包含的mysqldump，可以减少2/3的还原时间）。

*物理备份的好处*

- 基于文件的物理备份，只需要将需要的文件复制到其他地方即可完成备份。不需要其他额外工作来生成原始文件。
- 对于MyISAM，只需要简单复制文件到目的地。对于InnoDB则需要停止数据库服务。
- InnoDB和MyISAM的物理备份非常容易夸平台、操作系统和MySQL版本。
- 从物理备份恢复更快，因为MySQL服务器不需要执行任何SQL或构建索引。事实上，逻辑备份最不确定的就是还原时间。

*物理备份缺点*

- InnoDB的原始文件通常比相应的逻辑备份要大得多。
- 物理备份不总是可以跨平台、操作系统以及MySQL版本。文件名大小写敏感和浮点格式可能会遇到麻烦。很可能因为浮点格式不同而不能移动文件到另一个系统。

建议混合使用物理和逻辑两种方式来备份：先使用物理复制，以此数据启动MySQL服务器实例并运行mysqlcheck。然后周期性地使用mysqldump执行逻辑备份。这样做可以获得两种方法的优点，不会使生产服务器在导出时有过度负担。

如果能够方便地利用文件系统的快照，也可以生成一个快照，将该快照复制到另一个服务器上并释放，然后测试原始文件，再执行逻辑备份。

---

### 需要备份什么内容

最简单的策略是只备份数据和表定义。下面是生产环境恢复数据库需要考虑的几点：

1. 不要忘记那些容易被忽视的数据：例如，二进制日志和InnoDB事务日志。
2. 备份MySQL的代码，比如触发器和存储过程。
3. 如果恢复一个涉及复制关系的服务器，应该备份所有与复制相关的文件，例如：二进制文件、中继日志、日志索引文件和.info文件。和SHOW MASTER和/或SHOW SLAVE STATUS的输出。
4. 服务器的配置文件
5. 对于服务器配置来说，备份中对生产服务器至关重要的任何外部配置，都十分重要。在UNIX服务器上，这可能包括cron任务，用户和组的配置、管理脚本，以及sudo规则。

---

### 增量备份和差异备份

差异备份是对上次全备份后*所有改变的部分*而做的备份。增量备份则是从任意类型的上次备份后所有修改做的备份。差异备份和增量备份有什么区别？

增量和差异备份都是部分备份：它们一般不包含完整的数据集。例如，可以用Percona XtraBackup和MySQL Enterprise Backup。

建议：

- 使用Percona XtraBackup和MySQL Enterprise Backup中的增量备份特性。
- 备份二进制日志。可以在每次备份好后使用FLUSH LOGS来开始一个新的二进制日志，这样就只需要备份新的二进制日志。
- 不要备份没有改变的表。
- 不要备份没有改变的行。如果一个表只做插入，例如记录网页页面点击的表，那么可以增加一个时间戳的列，然后只备份上次备份后插入的行。
- 有些数据根本没有必要备份。例如，有一个人从其他数据构建的数据仓库，从技术上来讲完全是冗余的。
- 备份所有的数据，然后发送到一个有去重复性的目的地。

不管怎样，还是需要经常做全备--建议至少一周一次。

---

### 存储引擎和一致性

问题：对于给定的存储引擎，如何得到一致的备份？

两类一致性需要考虑：**数据一致性**和**文件一致性**。

**数据一致性**

当备份时，应该考虑是否需要数据在指定时间点一致。

如果做在线备份，可能需要所有相关表的一致性备份。如果使用的不是事务型存储引擎，则只能在备份时使用LOCK TABLES来锁住所有要一起备份的表。备份完成后再释放锁。

InnoDB的多版本控制功能可以帮到我们。开始一个事务，转储一组相关的表，然后提交事务。（如果使用了事务获取一致性备份，则不能用LOCK TABLES，因为它会隐式地提交事务）

只要在服务器上使用 REPEATABLE READ事务隔离级别，并且没有任何DDL，就一定会有完美的一致性，以及基于时间点的数据快照，且在备份过程中不会阻塞任何后续工作。

也可以用mysqldump来获得InnoDB表的一致性逻辑备份，采用 --single-transaction选项可以按照我们描述的那样工作。但会导致一个非常漫长的事务。

**文件一致性**

例如，一条大的UPDATE语句执行时备份反映不出文件的状态，并且所有要备份的文件相互之间也应一致。如果没有内部一致的文件，那么还原时可能会感到惊讶，所以要保证多个文件之间的一致性。

对于非事务性存储引擎，例如MyISAM，可能的选项是锁住并刷新表。操作方式是，要么用LOCK TABLES 和FLUSH TABLES结合的方法以使服务器将内存中的变更刷新到磁盘上，要么用FLUSH TABLES WITH READ LOCK。一旦刷新完成，就可以安全地复制MyISAM的原始文件。

对于InnoDB，确保文件一致性更困难。即使使用了FLUSH TABLES WITH READ LOCK，InnoDB依旧在后台运行，比如，插入缓存、日志和写线程继续将变更合并到日志和表空间文件中。这些线程设计是异步的。在后台执行这些进程可以帮助InnoDB取得更高的并发性。所以它们与LOCK TABLES无关。

如何解决问题？

- 等待直到InnoDB的清除线程和插入缓冲合并线程完成。可以观察SHOW INNODB STATUS的输出，当没有脏缓存或挂起的写时，就可以复制文件。由于InnoDB的后台线程涉及太多干扰，所以不推荐这种方法。
- 在一个类似LVM的系统中获取数据和日志文件一致的快照，必须让数据和日志文件在快照时相互一致。
- 发送一个STOP信号给MySQL,做备份。然后再发送一个CONT信号来再次唤醒MySQL。如果备份的时候需要关闭服务器，那么推荐这种方法。

为什么要建立备份数据库？

因为从备库中备份最大的好处是可以不干扰住库。避免在主库上增加额外的负载。也可以把备份用的备库用于其他用途，例如报表服务器。

当从备库中备份时，应该保存所有关于复制进程的信息。例如备库相对于住库的位置。这非常有用：比如克隆新的备库，重新应用二进制日志到主库上以获得指定时间的恢复，将备库提升为主库等等。

如果停止备库，需要确保没有打开的临时表。怎么做才能确保没有打开的临时表？备库可以放到其他地方吗？比如不同的主机。

>通常认为备库和主库是一样的，但实际经验是不一样。怎么查看两者之间的差异呢？使用：Percona Toolkit 中的pt-table-checksum之类的工具。拥有一个复制的备库可能在主库损坏时提供帮助，但不能提供保证。复制不是备份。

--- 

### 管理和备份二进制日志

二进制日志的备份是非常重要的。并且由于比数据要小，所以更容易进行频繁的备份。如果有某个时间点的数据备份和所有从那时以后的二进制日志，就可以重放自从上次全备以来的二进制日志并“前滚”所有的变更。**二进制日志文件是怎么记录的？**

保证二进制日志文件的安全，可以将它们保存在SAN上（WHATS SAN?）上，或用DRBD复制到另外一个设备上。

如果不能承受丢失超过30分钟数据的价值。至少每30分钟就备份一次。也可以用一个配置 --log_slave_update的只读备库，这样可以获得额外的安全性。

MySQL 5.6 版本的mysqlbinlog有一个非常方便的特性，可以连接到服务器上来是实时对二进制日志做镜像。比运行一个mysqld实例要简单和轻便。






