[TOC]

复制主要解决的基本问题是让一台服务器的数据与其他服务器保持同步。

MySQL支持两种复制方式：

1. 基于行的复制
2. 基于语句的复制（逻辑复制）

这两种方式都是通过在主库上记录二进制日志、在备库上重放日志的方式来实现异步的数据复制。

### 复制解决的问题

*数据分布*

位于不同的地理位置的数据。

*负载均衡*

通过MySQL复制可以将读操作分布到多个服务器上。实现对密集型应用的优化。

对于小规模应用，可以简单地对机器做硬编码或使用DNS轮询（将一个机器名指向多个IP地址）。

高可用性和故障切换。

做MySQL升级测试，使用一个更高版本的MySQL作为备库。

### 复制的工作原理

1. 在主库上把数据更改记录到二进制日志中（Binary Lo通知g）中。
2. 备库将主库上的日志复制到自己的中继日志中（Relay Log）中。
3. 备库读取中继日志中的事件，将其重放到备库数据之上

复制的大致过程：

1. 在每台服务器上创建复制帐号。
2. 配置主库和备库。
3. 通知备库连接到主库并从主库复制数据。

在服务器端和客户端创建复制账户：
```
mysql> GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.*
    -> TO repl@'192.168.0.%' IDENTIFIED BY 'p4ssword',;
```

### 配置主库和备库

假设主库为server1：

- 打开二进制日志功能
- 指定一个独一无服务器ID

在主库的my.cnf中增加如下内容：
```
log_bin   = mysql-bin
server_id = 10
```

重启主库mysql服务，用`show master status;` 会看到内容。

在备库上的配置：

```
log_bin     = mysql-bin
server_id   = 2
relay_log   = /var/lib/mysql/mysql-relay-bin
log_slave_updates = 1
read_only   = 1
```

*启动复制*

```
mysql> change master to MASTER_HOST='server1',
    -> MASTER_USER='repl',
    -> MASTER_PASSWORD='p4ssword',
    -> MASTER_LOG_FILE='mysql-bin.000001',
    -> MASTER_LOG_POS=0;
```

查看备库的状态：

`SHOW SLAVE STATUS\G`

运行下面的命令开始复制：

`mysql> START SLAVE;`

再次查看SLAVE的状态：

`SHOW SLAVE STATUS\G`

查看复制线程：

`SHOW PROCESSLIST\G`

### 从另一个服务器开始复制 

主库和备库保持同步的三个条件：

- 在某个时间点的主库的数据快照
- 主库当前的二进制日志文件，和获得数据快照时在该二进制日志文件中的偏移量。我们把这两个值称为日志文件坐标（log file coordinates）。通过这两个值可以确定二进制日志的位置。
- 从快照时间到现在的二进制日志。

从别的服务器克隆备库的方法：

*使用冷备份*

最基本的方法是关闭主库，把数据复制到备库。重启主库后，会使用一个新的二进制日志文件，我们在备库通过执行CHANGE MASTER TO指向这个文件的起始处。

*使用热备份*

如果仅使用了MyISAM表，可以在主库运行时使用`mysqlhotcopy`或`rsync`来复制数据。

*使用mysqldump*

如果只包含InnoDB表，那么可以使用以下命令来转储主库数据并将其加载到备库，然后设置相应的二进制日志坐标：

```bash
$ mysqldump --single-transaction --all-databases --master-data=1--host=server1  | mysql --host=server2
```

选项`--single-transaction`使得转储的数据为事务开始前的数据。如果使用的是非事务型表，可以使用`lock-all-tables`选项来获得所有表的一致性转储

*使用快照或备份*

只要知道对应的二进制日志坐标，就可以使用主库的快照或备份来初始化备库（如果使用备份，需要确保从备份的时间点开始的主库二进制日志都要存在）。然后只需要使用CHANGE MASTER TO制定二进制日志的坐标。

### 推荐的复制配置

在主库上配置二进制日志最重要的选项是sync_binlog:

```
sync_binlog=1
```

如果开启该选项，MySQL每次在提交事务前会将二进制日志同步到磁盘上，保证服务器在崩溃时不会丢失事件。它只适用于二进制日志，而非中继日志。在备库上不推荐此配置。

如果无法容忍服务器崩溃导致表损坏，推荐使用InnoDB。

如果使用InnoDB，我们强烈推荐如下配置：

```
innodb_flush_logs_at_trx_commit # Flush every log write
innodb_support_xa=1             # MySQL 5.0 and newer only
innodb_safe_binlog              # MySQL 4.1 only, roughly enquivalent to
                                # innodb_support_xa
```

给二进制日志命名：

```
log_bin=/var/lib/mysql/mysql-bin # Good; specifies a path and base name
#log_bin                         # Bad; base name will be server's hostname
```

在备库上，我们同样推荐开启如下配置选项，为中继日志指定绝对路径:

```
relay_log=/path/to/logs/relay-bin
skip_slave_start
read_only
```

通过配置relay_log可以避免中继日志文件基于机器名来命名。防止之前提到的可能在主库发生的问题。指定绝对路径可以避免多个MySQL版本中存在的Bug，这些Bug可能会导致中继日志在一个意料外的位置创建。skip_slave_start选项能够阻止备库在崩g溃后自动启动复制。

read_only可以阻止大部分用户更改非临时表。

如果正在使用MySQL5.5并且不介意额外的fsync()导致的性能开销，最好设置以下选项：

```
sync_master_info    = 1
sync_relay_log      = 1
sync_relay_log_info = 1
```

MySQL复制基于主服务器在二进制日志中**跟踪所有对数据库的更改**。因此，要进行复制，必须在主服务器上启用二进制日志。思考一下，如果我要对运行中的数据库做拷贝。改怎么办？生产服务器上的数据每时每刻都是在变的。如果从我拷贝的那一刻起，我启用二进制日志，这时，二进制日志文件就开始记录客户端对数据库的操作；当我成功把数据拷贝到从服务器时，我再把二进制日志文件也拷贝过来，通过这个二进制日志文件来重新执行二进制日志当中的新的操作的SQL语句。

还有就是，每当我执行`flush logs;` 的时候，系统就会新增一个二进制日志文件。

二进制日志只是一个从启用二进制日志的固定时间点开始的记录。任何设置的从服务器需要主服务器上的在主服务器上启用二进制日志时的数据库拷贝。

### 基于语句的复制

基于语句的复制模式下，主库会记录那些造成数据更改的 *查询*，当备库读取并重放这些事件时，实际上只是把主库上执行过的SQL再执行一遍。

### 基于行的复制

这种方式会将实际数据记录在二进制日志中。

### 基于行或基于语句：哪种更优

理论上基于行的复制模式整体上更优，并且在实际应用中也适用于大多数场景。

*基于语句的复制模式的优点：*

当主备的模式不同时，逻辑复制能够在多种情况下工作。

基于语句的方式执行复制的过程基本上是执行SQL语句。

*基于语句的复制模式的缺点：*

很多情况下通过基于语句的模式无法正确复制，几乎每一个安装的备库都会碰到一次。

如果使用触发器或存储过程，就不要使用基于语句的复制模式。除非能够清楚地确定不会遇到复制问题。

*基于行的复制模式的优点：*

几乎没有基于行的复制模式无法处理的场景。

这种方式可能减少锁的使用，因为它并不要求这种强串行化是可重复的。

基于行的复制模式会记录数据变更，因此在二进制日志中记录的都是实际上在主库上发生了变化的数据。

占用更少的CPU。

能够解决数据不一致的问题。

*基于行的复制模式的缺点：*

由于执行基于行的复制的过程不可见，并且没有很好的文档和解释，因此出现问题很难找到问题的所在。

### 复制文件

复制文件会使用到的一些文件。除了二进制日志文件和中继日志文件外，还有其他文件会被用到。

那些其他文件可能在data目录或包含服务器.pid文件的目录下

*mysql-bin.index*

用于记录磁盘上的二进制日志文件。这个文件的每一行包含了二进制文件的文件名。

*mysql-relay-bin-index*

这个文件是中继日志的索引文件，和mysql-bin.index的作用类似

*relay-log.info*

这个文件包含了当前备库复制的二进制日志和中继日志坐标（例如备库复制在主库上的位置。）

删除二进制日志：

```
PURGE BINARY LOGS TO 'mysql-bin.000001';
PURGE BINARY LOGS BEFORE '2008-04-02 22:46:26';
```

最好能够显式地执行一些日志清理策略，比如设置expire_logs_days参数或其他方式。否则MySQL的二进制日志可能会将磁盘撑满。

### 发送复制事件到其他备库

`log_slave_updates`选项可以让备库变成其他服务器的主库。在设置改选项后，MySQL会将其执行过的事件记录到它自己的二进制日志中，这样它的备库就可以从其日志中检索并执行事件。

### 复制过滤器

复制过滤选项允许你仅复制服务器上的一部分数据。

两种复制过滤的方式：

1. 在主库上过滤记录到二进制日志中的事件。
2. 在备库上过滤记录到中继日志的事件。

用binlog_do_db和binlog_ignore_db来控制过滤。

二进制日志包括一组存储实际内容的二进制日志文件和一个二进制日志索引文件，而二进制索引文件包含所有使用的二进制日志文件的文件名，它用来跟踪存在的二进制日志文件。

*二进制日志文件的结构*

二进制日志文件由二进制日志索引文件，二进制日志文件，当前活动二进制日志文件组成。

活动二进制日志文件(active binlog file)，即当前正在被写入的文件。

每个二进制日志文件都以格式描述事件(format description event)开始，以日志轮换事件(rotate event)结束

格式描述日志事件包括产生该文件的服务器版本号，服务器信息及二进制日志信息等。日志轮换事件包含下一个二进制日志文件的名称，以告知二进制日志继续写入哪个文件。

如果MySQL服务器崩溃了，那么会检测二进制日志文件的写入标记，如果有这个代表写入的标记，说明二进制日志没有关闭。如果没有这个代表写入的标记，说明二进制日志文件已经关闭。

用`SHOW MASTER STATUS\G`查看当前正在写入的是哪个二进制日志文件。

停止并重置SLAVE
```
STOP SLAVE;
RESET SLAVE;
```

删除标，然后重置Master刷新：
```
DROP TABLE tbl;
RESET MASTER;
```

RESET MASTER 命令删除了所有二进制日志文件并清空了二进制索引文件。
RESET SLAVE 命令删除了Slave复制所用的所有文件。

无论是RESET MASTER 还是RESET SLAVE 都是运行复制时有效。因此：

- 执行RESET MASTER 命令时，确保没有Slave连接到该Master
- 执行RESET SLAVE 命令时，先执行STOP SLAVE命令，确保Slave上没有活动的复制

*可以用Python来管理复制，恩，想想很酷！*

基本思想是建立一个服务器如何连接到计算机（任何计算机，比如笔记本）的模型，并设计程序库，通过改变模型来管理连接。

引导Slave：

CHANGE MASTER TO 有两个有用的参数：`MASTER_LOG_FILE`和`MASTER_LOG_POS`。使用这些参数指定Master开始发送事件的binlog位置，而不是从头开始。

### 一般常用的备份

即是运行mysql dump命令来创建逻辑备份。

其他备份技术：

1. 拷贝数据库文件创建物理备份
2. 在线备份技术如InnoDB Hot Backup

### 克隆Master

克隆Master首先要创建Master的备份。由于Master可能正在运行，而且缓存中有很多表，所以需要刷新（flush）所有表并锁定数据库，防止在检查binlog位置之前数据库发生改变。
```
FLUSH TABLES WITH READ LOCK;
```

锁定后执行 `SHOW MASTER STATUS\G` 会发现二进制日志文件现在不会改变了，因为被锁住了。那么下一个将要写入的事件的起点就是这个命令所显示出来的内容的二进制日志文件名和偏移值，即是：master-bin.000042, 456552。以下是创建备份的方法：
```
mysqldump --all-databases --host=master-1 > backup.sql
```

然后解锁master的数据库：
```
master> UNLOCK TABLES;
```

然后在slave上恢复数据库：
```
mysql --host=slave-1 < backup.sql
```

然后启动Slave并进入MySQL：
```
Slave> CHANGE MASTER TO
> MASTER_HOST = 'master-1',
> MASTER_PORT = 3306,
> MASTER_USER = 'slave-1',
> MASTER_PASSWORD = 'xyzzy',
> MASTER_LOG-FILE = 'master-bin.000042',
> MASTER_LOG_POS = 456552
```

最后开始同步：
```
START SLAVE;
```

要对服务器上的所有数据进行逻辑备份，输入：
```
mysqldump --host=master -all-databases \
> --master-data=1 >backup-source.sql
```

--master-data=1选项使mysqldump写CHANGE MASTER TO语句，且参数为二进制日志文件及其位置。

然后就可以在Slave上恢复了：
```
mysql --host=slave-1 < backup-source.sql
```

### 复制拓扑
可以在任意多个主库和备库之间建立复制，只有一个限制：每个备库只能有一个主库。

记住以下基本原则：
- 一个MySQL备库实例只能有一个主库。
- 每个备库必须有一个唯一的服务器ID。
- 一个主库可以多个备库（或者相应的，一个备库可以有多个兄弟被备库）。
- 如果打开了`log_slave_updates`选项，一个备库可以把主库上的数据变化传播到其他备库。

如果有重复的服务器ID，它们将陷入竞争，并反复将对方从主库上踢出。

一主多备的应用场景：
- 为不同的角色使用不同的备库（例如添加不同的索引或使用不同的存储引擎）。
- 把一台备库当作待使用的主库，除了复制没有其他数据传输。
- 将一台备库放到远程数据中心，用作灾难恢复。
- 延迟一个或多个备库，以备灾难恢复。
- 使用其中一个备库，作为备份、培训、开发或测试使用的服务器。

**主-主复制**

MySQL不支持多主库复制。

如果同时在两台服务器上向一个包含AUTO_INCREMENT列的表里插入数据

MySQL5.0的解决方案：

- 设置auto_increment_increment和auto_increment_offset。通过这两个选项可以让MySQL自动为INSERT语句选择不互相冲突的值。

**主动-被动模式下的主-主复制**

主要区别在于其中的一台服务器是只读的被动服务器

这种方式使得反复切换主动和被动服务器非常方便，因为服务器的配置是对称的。这使得故障转移和故障恢复很容易。它也可以让你在不关闭服务器的情况下执行维护、优化表、升级操作系统或其他任务。

*例如，执行ALTER TABLE操作可能会锁住整个表，阻塞对表的读和写，这可能会花费很长时间并导致服务中断。然而在主-主配置下，可以先停止主服务器上的备库复制线程(这样就不会在被动服务器上执行任何更新)，然后在被动服务器上执行ALTER操作，交换角色，最后在先前的主动服务器上启动复制线程。这个服务器会读取中继日志并执行相同的ALTER语句。*

可以通过设置SQL_LOG_BIN=0来暂时禁止记录二进制日志而无须停止复制。一些语句，例如Optimize TABLE，也支持LOCAL或NO_WRITE_TO_BINLOG这些停止日志的选项。

让我们看看如何配置主-主服务器对，在两台服务器上执行如下设置后，会使其拥有对称的设置：
1. 确保两台服务器上有相同的数据。
2. 启动二进制日志，选择唯一的服务器ID，并创建复制账号。
3. 启用备库更新的日志记录，后面将会看到，这是故障转移和故障恢复的关键。
4. 把被动服务器设置成只读，防止可能与主动服务器上的更新产生冲突，这一点是可选的。
5. 启动每个服务器的MySQL实例。
6. 将每个主库设置为对方的备库，使用新创建的二进制日志开始工作。

如果主库上更新记录会发生什么事？

1. 更新被记录到二进制日志中，通过复制传递给被动服务器的中继日志中。
2. 被动服务器执行查询并将其记录到自己的二进制日志中（因为开启了log_slave_updates选项）。
3. 由于事件的服务器ID与主动服务器的相同，因此主动服务器将忽略这些事件(备库上的事件)。

设置主动-被动的主-主拓扑结构在某种意义上类似于创建一个热备份，但是可以使用这种“备份”来提高性能。例如，用它来执行读操作、备份、“离线”维护及升级等。但是，不会获得比单台服务器更好的写性能。

### 拥有备库的主-主结构
另外一种相关的配置是为每个主库增加一个备库。

这种配置的优点是增加了冗余，对于不同地理位置的复制拓扑，能够消除站点单点失效的问题。也可以将读查询分配到备库上。

### 环形复制

双主结构实际上是环形结构的一种特例。环形结构可以有三个或更多的主库。每个服务器都是在它之前的服务器的备库，是在它之后的服务器的主库。这种结构也称为环形复制(circular replication)

### 主库、分发主库以及备库
当备库足够多时，会对主库造成很大的负载。每个备库会在主库上创建一个线程，并执行`binlog dump`命令。该命令会读取二进制日志文件中的数据并将其发送给备库。每个备库都会重复这样的工作，它们不会共享`binlog dump`的资源。

如果有很多备库，并且有大的事件时，例如一次很大的LOAD DATA INFILE操作，主库上的负载会显著上升，甚至可能由于备库同时请求同样的事件而耗尽内存并并崩溃。此外，如果备库请求的数据不再文件系统的缓存中，可能会导致大量的磁盘检索，这同样会影响主库的性能并增加锁的竞争。

因此，如果需要多个备库，一个好办法是从主库移除负载并使用分发主库。分发主库事实上也是一个备库，它的唯一目的就是提取和提供主库的二进制日志。多个备库连接到分发主库，这使原来的主库摆脱了负担。为了避免在分发主库上做实际的查询，可以将它的表修改为blackhole存储引擎。

某些情况下，可以通过设置`slave_compressed_protocol`来节约一些主库带宽。对跨数据中心复制很有好处。

还可以通过分发主库实现其他目的，例如，对二进制日志事件执行过滤和重写规则。这比在每个备库上重复进行日志记录、重写和过滤要高得多。

如何确保分发服务器上的每个表都是`blackhole`存储引擎。不管什么时候，在备库上使用不同的存储引擎总会导致同样的问题。常见的解决方案是设置服务器的`storage_engine`选项：
```
storage_engine = blackhole
```

这只会影响那些没有指定存储引擎的`CREATE TABLE`语句。如果有一个无法控制的应用，这种拓扑结构可能会非常脆弱。可以通过skip_innodb选项禁止InnoDB，将表退化为MyISAM。但你无法禁止MyISAM或者Memory引擎。

>使用分发主库另外一个主要的缺点是无法使用一个备库来代替主库。因为由于分发主库的存在，导致各个备库与原始主库的二进制日志坐标已经不相同。

### 定制的复制方案
典型的定制方案包括组合过滤、分发和向不同的存储引擎复制。

为了利用访问局部性原理（locality of reference），并将需要读的工作集驻留在内存中，可以复制少量数据到备库中。如果每个备库只拥有主库的一部分数据，并且将读分配给备库，就可以更好地利用备库的内存。

水平数据划分，它的优势在于主库包含了所有的数据集，这意味着无须为了一条写入查询去访问多个服务器。如果读操作无法在备份库上找到数据，还可以通过主库来查询。即使不能从备库上读取所有的数据，也可以移除大量的主库读负担。

最简单的方法是在主库上将数据划分到不同的数据库里。然后将每个数据库复制到不同的备库上。每个备库通过选项`replicate_wild_do_table`选项来限制给定数据库的数据。下面是sales数据库的配置：
```
replicate_wild_do_table = sales.%
```

**分离功能**

在线事务处理（OLTP），在线数据分析（OLAP），OLTP查询比较短并且是事务型的，OLAP查询则通常很大，也很慢，并且不要求绝对最新的数据。这两种查询给服务器带来的负担完全不同，因此它们需要不同的配置，甚至可能使用不同的存储引擎或者硬件。

**数据归档**

可以在备库上实现数据归档，也就是说可以在备库上保留主库上删除过的数据，在主库上通过delete语句删除数据是确保delete语句不传递到备库就可以实现。

实现方法：
1. 在主库上选择性地禁止二进制日志
2. 在备库上使用replicate_ignore_db规则

这两种方法很危险。

第一种方法是需要先将SQL_LOG_BIN设置为0,然后再进行数据清理。这种方法的好处是不需要在备库进行任何配置，由于SQL语句根本没有记录到二进制日志中，效率会稍微有所提升。最大的缺点是没有将主库的修改记录下来，因此无法使用二进制日志来进行审计或者做按时间点的数据恢复。另外还需要SUPER权限。

第二种方法是在清理数据之前对主库上特定的数据库使用USE语句。例如可以创建一个名为purge的数据库，然后在备库的my.cnf文件里设置`replicate_ignore_db=purge`并重启服务器。这种方法没有第一种方法的缺点，但有一个小小的缺点：备库需要去读取它不需要的事件。另外，也可能有人在purge数据库上执行非清理查询，从而导致备库无法重放该事件。

Percona Toolkit中的pt-archiver支持以上两种方式。

### 将备库用做全文检索
一个普遍的做法是配置一台备库，将某些表设置为MyISAM存储引擎，然后创建全文索引擎，然后创建全文索引并执行全文索引查询。这避免了在主库上同时使用事务型和非事务型存储引擎所带来的复制问题，减轻了主库维护全文索引的负担。

**只读备库**

许多机构选择将备库设置为只读，以防止在备库进行的无意识修改导致复制中断。可以通过设置`read_only`选项来实现。它会禁止大部分写操作，除了复制线程和拥有超级权限的用户以及临时表操作。只要不给普通用户超级权限，这应该是很完美的方法。
