复制主要解决的基本问题是让一台服务器的数据与其他服务器保持同步。

MySQL支持两种复制方式：

1. 基于行的复制
2. 基于语句的复制（逻辑复制）

这两种方式都是通过在主库上记录二进制日志、在备库上重放日志的方式来实现异步的数据复制。

### 复制解决的问题

*数据分布*

位于不同的地理位置的数据。

*负载均衡*

通过MySQL复制可以将读操作分布到多个服务器上。实现对密集型应用的优化。

对于小规模应用，可以简单地对机器做硬编码或使用DNS轮询（将一个机器名指向多个IP地址）。

高可用性和故障切换。

做MySQL升级测试，使用一个更高版本的MySQL作为备库。

### 复制的工作原理

1. 在主库上把数据更改记录到二进制日志中（Binary Lo通知g）中。
2. 备库将主库上的日志复制到自己的中继日志中（Relay Log）中。
3. 备库读取中继日志中的事件，将其重放到备库数据之上

复制的大致过程：

1. 在每台服务器上创建复制帐号。
2. 配置主库和备库。
3. 通知备库连接到主库并从主库复制数据。

在服务器端和客户端创建复制账户：
```
mysql> GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.*
    -> TO repl@'192.168.0.%' IDENTIFIED BY 'p4ssword',;
```

### 配置主库和备库

假设主库为server1：

- 打开二进制日志功能
- 指定一个独一无服务器ID

在主库的my.cnf中增加如下内容：
```
log_bin   = mysql-bin
server_id = 10
```

重启主库mysql服务，用`show master status;` 会看到内容。

在备库上的配置：

```
log_bin     = mysql-bin
server_id   = 2
relay_log   = /var/lib/mysql/mysql-relay-bin
log_slave_updates = 1
read_only   = 1
```

*启动复制*

```
mysql> change master to MASTER_HOST='server1',
    -> MASTER_USER='repl',
    -> MASTER_PASSWORD='p4ssword',
    -> MASTER_LOG_FILE='mysql-bin.000001',
    -> MASTER_LOG_POS=0;
```

查看备库的状态：

`SHOW SLAVE STATUS\G`

运行下面的命令开始复制：

`mysql> START SLAVE;`

再次查看SLAVE的状态：

`SHOW SLAVE STATUS\G`

查看复制线程：

`SHOW PROCESSLIST\G`

### 从另一个服务器开始复制 

主库和备库保持同步的三个条件：

- 在某个时间点的主库的数据快照
- 主库当前的二进制日志文件，和获得数据快照时在该二进制日志文件中的偏移量。我们把这两个值称为日志文件坐标（log file coordinates）。通过这两个值可以确定二进制日志的位置。
- 从快照时间到现在的二进制日志。

从别的服务器克隆备库的方法：

*使用冷备份*

最基本的方法是关闭主库，把数据复制到备库。重启主库后，会使用一个新的二进制日志文件，我们在备库通过执行CHANGE MASTER TO指向这个文件的起始处。

*使用热备份*

如果仅使用了MyISAM表，可以在主库运行时使用`mysqlhotcopy`或`rsync`来复制数据。

*使用mysqldump*

如果只包含InnoDB表，那么可以使用以下命令来转储主库数据并将其加载到备库，然后设置相应的二进制日志坐标：

```bash
$ mysqldump --single-transaction --all-databases --master-data=1--host=server1  | mysql --host=server2
```

选项`--single-transaction`使得转储的数据为事务开始前的数据。如果使用的是非事务型表，可以使用`lock-all-tables`选项来获得所有表的一致性转储

*使用快照或备份*

只要知道对应的二进制日志坐标，就可以使用主库的快照或备份来初始化备库（如果使用备份，需要确保从备份的时间点开始的主库二进制日志都要存在）。然后只需要使用CHANGE MASTER TO制定二进制日志的坐标。

### 推荐的复制配置

在主库上配置二进制日志最重要的选项是sync_binlog:

```
sync_binlog=1
```

如果开启该选项，MySQL每次在提交事务前会将二进制日志同步到磁盘上，保证服务器在崩溃时不会丢失事件。它只适用于二进制日志，而非中继日志。在备库上不推荐此配置。

如果无法容忍服务器崩溃导致表损坏，推荐使用InnoDB。

如果使用InnoDB，我们强烈推荐如下配置：

```
innodb_flush_logs_at_trx_commit # Flush every log write
innodb_support_xa=1             # MySQL 5.0 and newer only
innodb_safe_binlog              # MySQL 4.1 only, roughly enquivalent to
                                # innodb_support_xa
```

给二进制日志命名：

```
log_bin=/var/lib/mysql/mysql-bin # Good; specifies a path and base name
#log_bin                         # Bad; base name will be server's hostname
```

在备库上，我们同样推荐开启如下配置选项，为中继日志指定绝对路径:

```
relay_log=/path/to/logs/relay-bin
skip_slave_start
read_only
```

通过配置relay_log可以避免中继日志文件基于机器名来命名。防止之前提到的可能在主库发生的问题。指定绝对路径可以避免多个MySQL版本中存在的Bug，这些Bug可能会导致中继日志在一个意料外的位置创建。skip_slave_start选项能够阻止备库在崩g溃后自动启动复制。

read_only可以阻止大部分用户更改非临时表。

如果正在使用MySQL5.5并且不介意额外的fsync()导致的性能开销，最好设置以下选项：

```
sync_master_info    = 1
sync_relay_log      = 1
sync_relay_log_info = 1
```

MySQL复制基于主服务器在二进制日志中**跟踪所有对数据库的更改**。因此，要进行复制，必须在主服务器上启用二进制日志。思考一下，如果我要对运行中的数据库做拷贝。改怎么办？生产服务器上的数据每时每刻都是在变的。如果从我拷贝的那一刻起，我启用二进制日志，这时，二进制日志文件就开始记录客户端对数据库的操作；当我成功把数据拷贝到从服务器时，我再把二进制日志文件也拷贝过来，通过这个二进制日志文件来重新执行二进制日志当中的新的操作的SQL语句。

还有就是，每当我执行`flush logs;` 的时候，系统就会新增一个二进制日志文件。

二进制日志只是一个从启用二进制日志的固定时间点开始的记录。任何设置的从服务器需要主服务器上的在主服务器上启用二进制日志时的数据库拷贝。

### 基于语句的复制

基于语句的复制模式下，主库会记录那些造成数据更改的 *查询*，当备库读取并重放这些事件时，实际上只是把主库上执行过的SQL再执行一遍。

### 基于行的复制

这种方式会将实际数据记录在二进制日志中。

### 基于行或基于语句：哪种更优

理论上基于行的复制模式整体上更优，并且在实际应用中也适用于大多数场景。

*基于语句的复制模式的优点：*

当主备的模式不同时，逻辑复制能够在多种情况下工作。

基于语句的方式执行复制的过程基本上是执行SQL语句。

*基于语句的复制模式的缺点：*

很多情况下通过基于语句的模式无法正确复制，几乎每一个安装的备库都会碰到一次。

如果使用触发器或存储过程，就不要使用基于语句的复制模式。除非能够清楚地确定不会遇到复制问题。

*基于行的复制模式的优点：*

几乎没有基于行的复制模式无法处理的场景。

这种方式可能减少锁的使用，因为它并不要求这种强串行化是可重复的。

基于行的复制模式会记录数据变更，因此在二进制日志中记录的都是实际上在主库上发生了变化的数据。

占用更少的CPU。

能够解决数据不一致的问题。

*基于行的复制模式的缺点：*

由于执行基于行的复制的过程不可见，并且没有很好的文档和解释，因此出现问题很难找到问题的所在。

### 复制文件

复制文件会使用到的一些文件。除了二进制日志文件和中继日志文件外，还有其他文件会被用到。

那些其他文件可能在data目录或包含服务器.pid文件的目录下

*mysql-bin.index*

用于记录磁盘上的二进制日志文件。这个文件的每一行包含了二进制文件的文件名。

*mysql-relay-bin-index*

这个文件是中继日志的索引文件，和mysql-bin.index的作用类似

*relay-log.info*

这个文件包含了当前备库复制的二进制日志和中继日志坐标（例如备库复制在主库上的位置。）

删除二进制日志：

```
PURGE BINARY LOGS TO 'mysql-bin.000001';
PURGE BINARY LOGS BEFORE '2008-04-02 22:46:26';
```

最好能够显式地执行一些日志清理策略，比如设置expire_logs_days参数或其他方式。否则MySQL的二进制日志可能会将磁盘撑满。

### 发送复制事件到其他备库

`log_slave_updates`选项可以让备库变成其他服务器的主库。在设置改选项后，MySQL会将其执行过的事件记录到它自己的二进制日志中，这样它的备库就可以从其日志中检索并执行事件。

### 复制过滤器

复制过滤选项允许你仅复制服务器上的一部分数据。

两种复制过滤的方式：

1. 在主库上过滤记录到二进制日志中的事件。
2. 在备库上过滤记录到中继日志的事件。

用binlog_do_db和binlog_ignore_db来控制过滤。
