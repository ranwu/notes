复制主要解决的基本问题是让一台服务器的数据与其他服务器保持同步。

MySQL支持两种复制方式：

1. 基于行的复制
2. 基于语句的复制（逻辑复制）

这两种方式都是通过在主库上记录二进制日志、在备库上重放日志的方式来实现异步的数据复制。

### 复制解决的问题

*数据分布*

位于不同的地理位置的数据。

*负载均衡*

通过MySQL复制可以将读操作分布到多个服务器上。实现对密集型应用的优化。

对于小规模应用，可以简单地对机器做硬编码或使用DNS轮询（将一个机器名指向多个IP地址）。

高可用性和故障切换。

做MySQL升级测试，使用一个更高版本的MySQL作为备库。

### 复制的工作原理

1. 在主库上把数据更改记录到二进制日志中（Binary Lo通知g）中。
2. 备库将主库上的日志复制到自己的中继日志中（Relay Log）中。
3. 备库读取中继日志中的事件，将其重放到备库数据之上

复制的大致过程：

1. 在每台服务器上创建复制帐号。
2. 配置主库和备库。
3. 通知备库连接到主库并从主库复制数据。

在服务器端和客户端创建复制账户：
```
mysql> GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.*
    -> TO repl@'192.168.0.%' IDENTIFIED BY 'p4ssword',;
```

### 配置主库和备库

假设主库为server1：

- 打开二进制日志功能
- 指定一个独一无服务器ID

在主库的my.cnf中增加如下内容：
```
log_bin   = mysql-bin
server_id = 10
```

重启主库mysql服务，用`show master status;` 会看到内容。

在备库上的配置：

```
log_bin     = mysql-bin
server_id   = 2
relay_log   = /var/lib/mysql/mysql-relay-bin
log_slave_updates = 1
read_only   = 1
```

*启动复制*

```
mysql> change master to MASTER_HOST='server1',
    -> MASTER_USER='repl',
    -> MASTER_PASSWORD='p4ssword',
    -> MASTER_LOG_FILE='mysql-bin.000001',
    -> MASTER_LOG_POS=0;
```

查看备库的状态：

`SHOW SLAVE STATUS\G`

运行下面的命令开始复制：

`mysql> START SLAVE;`

再次查看SLAVE的状态：

`SHOW SLAVE STATUS\G`

查看复制线程：

`SHOW PROCESSLIST\G`

### 从另一个服务器开始复制 

主库和备库保持同步的三个条件：

- 在某个时间点的主库的数据快照
- 主库当前的二进制日志文件，和获得数据快照时在该二进制日志文件中的偏移量。我们把这两个值称为日志文件坐标（log file coordinates）。通过这两个值可以确定二进制日志的位置。
- 从快照时间到现在的二进制日志。

从别的服务器克隆备库的方法：

*使用冷备份*

最基本的方法是关闭主库，把数据复制到备库。重启主库后，会使用一个新的二进制日志文件，我们在备库通过执行CHANGE MASTER TO指向这个文件的起始处。

*使用热备份*

如果仅使用了MyISAM表，可以在主库运行时使用`mysqlhotcopy`或`rsync`来复制数据。

*使用mysqldump*

如果只包含InnoDB表，那么可以使用以下命令来转储主库数据并将其加载到备库，然后设置相应的二进制日志坐标：

```bash
$ mysqldump --single-transaction --all-databases --master-data=1--host=server1  | mysql --host=server2
```

选项`--single-transaction`使得转储的数据为事务开始前的数据。如果使用的是非事务型表，可以使用`lock-all-tables`选项来获得所有表的一致性转储

*使用快照或备份*

只要知道对应的二进制日志坐标，就可以使用主库的快照或备份来初始化备库（如果使用备份，需要确保从备份的时间点开始的主库二进制日志都要存在）。然后只需要使用CHANGE MASTER TO制定二进制日志的坐标。

### 推荐的复制配置

在主库上配置二进制日志最重要的选项是sync_binlog:

```
sync_binlog=1
```

如果开启该选项，MySQL每次在提交事务前会将二进制日志同步到磁盘上，保证服务器在崩溃时不会丢失事件。它只适用于二进制日志，而非中继日志。在备库上不推荐此配置。

如果无法容忍服务器崩溃导致表损坏，推荐使用InnoDB。

如果使用InnoDB，我们强烈推荐如下配置：

```
innodb_flush_logs_at_trx_commit # Flush every log write
innodb_support_xa=1             # MySQL 5.0 and newer only
innodb_safe_binlog              # MySQL 4.1 only, roughly enquivalent to
                                # innodb_support_xa
```

给二进制日志命名：

```
log_bin=/var/lib/mysql/mysql-bin # Good; specifies a path and base name
#log_bin                         # Bad; base name will be server's hostname
```

在备库上，我们同样推荐开启如下配置选项，为中继日志指定绝对路径:

```
relay_log=/path/to/logs/relay-bin
skip_slave_start
read_only
```

通过配置relay_log可以避免中继日志文件基于机器名来命名。防止之前提到的可能在主库发生的问题。指定绝对路径可以避免多个MySQL版本中存在的Bug，这些Bug可能会导致中继日志在一个意料外的位置创建。skip_slave_start选项能够阻止备库在崩g溃后自动启动复制。

read_only可以阻止大部分用户更改非临时表。

如果正在使用MySQL5.5并且不介意额外的fsync()导致的性能开销，最好设置以下选项：

```
sync_master_info    = 1
sync_relay_log      = 1
sync_relay_log_info = 1
```

