复制主要解决的基本问题是让一台服务器的数据与其他服务器保持同步。

MySQL支持两种复制方式：

1. 基于行的复制
2. 基于语句的复制（逻辑复制）

这两种方式都是通过在主库上记录二进制日志、在备库上重放日志的方式来实现异步的数据复制。

### 复制解决的问题

*数据分布*

位于不同的地理位置的数据。

*负载均衡*

通过MySQL复制可以将读操作分布到多个服务器上。实现对密集型应用的优化。

对于小规模应用，可以简单地对机器做硬编码或使用DNS轮询（将一个机器名指向多个IP地址）。

高可用性和故障切换。

做MySQL升级测试，使用一个更高版本的MySQL作为备库。

### 复制的工作原理

1. 在主库上把数据更改记录到二进制日志中（Binary Lo通知g）中。
2. 备库将主库上的日志复制到自己的中继日志中（Relay Log）中。
3. 备库读取中继日志中的事件，将其重放到备库数据之上

复制的大致过程：

1. 在每台服务器上创建复制帐号。
2. 配置主库和备库。
3. 通知备库连接到主库并从主库复制数据。

在服务器端和客户端创建复制账户：
```
mysql> GRANT REPLICATION SLAVE, REPLICATION CLIENT ON *.*
    -> TO repl@'192.168.0.%' IDENTIFIED BY 'p4ssword',;
```

### 配置主库和备库

假设主库为server1：

- 打开二进制日志功能
- 指定一个独一无服务器ID

在主库的my.cnf中增加如下内容：
```
log_bin   = mysql-bin
server_id = 10
```

重启主库mysql服务，用`show master status;` 会看到内容。

在备库上的配置：

```
log_bin     = mysql-bin
server_id   = 2
relay_log   = /var/lib/mysql/mysql-relay-bin
log_slave_updates = 1
read_only   = 1
```

*启动复制*

```
mysql> change master to MASTER_HOST='server1',
    -> MASTER_USER='repl',
    -> MASTER_PASSWORD='p4ssword',
    -> MASTER_LOG_FILE='mysql-bin.000001',
    -> MASTER_LOG_POS=0;
```

查看备库的状态：

`SHOW SLAVE STATUS\G`

运行下面的命令开始复制：

`mysql> START SLAVE;`

再次查看SLAVE的状态：

`SHOW SLAVE STATUS\G`

查看复制线程：

`SHOW PROCESSLIST\G`

### 从另一个服务器开始复制 

主库和备库保持同步的三个条件：

- 在某个时间点的主库的数据快照
- 主库当前的二进制日志文件，和获得数据快照时在该二进制日志文件中的偏移量。我们把这两个值称为日志文件坐标（log file coordinates）。通过这两个值可以确定二进制日志的位置。
- 从快照时间到现在的二进制日志。

从别的服务器克隆备库的方法：

*使用冷备份*

最基本的方法是关闭主库，把数据复制到备库。重启主库后，会使用一个新的二进制日志文件，我们在备库通过执行CHANGE MASTER TO指向这个文件的起始处。

*使用热备份*

如果仅使用了MyISAM表，可以在主库运行时使用`mysqlhotcopy`或`rsync`来复制数据。

*使用mysqldump*

如果只包含InnoDB表，那么可以使用以下命令来转储主库数据并将其加载到备库，然后设置相应的二进制日志坐标：

```bash
$ mysqldump --single-transaction --all-databases --master-data=1--host=server1  | mysql --host=server2
```

选项`--single-transaction`使得转储的数据为事务开始前的数据。如果使用的是非事务型表，可以使用`lock-all-tables`选项来获得所有表的一致性转储

*使用快照或备份*

只要知道对应的二进制日志坐标，就可以使用主库的快照或备份来初始化备库（如果使用备份，需要确保从备份的时间点开始的主库二进制日志都要存在）。然后只需要使用CHANGE MASTER TO制定二进制日志的坐标。

### 推荐的复制配置

在主库上配置二进制日志最重要的选项是sync_binlog:

```
sync_binlog=1
```

如果开启该选项，MySQL每次在提交事务前会将二进制日志同步到磁盘上，保证服务器在崩溃时不会丢失事件。它只适用于二进制日志，而非中继日志。在备库上不推荐此配置。

如果无法容忍服务器崩溃导致表损坏，推荐使用InnoDB。

如果使用InnoDB，我们强烈推荐如下配置：

```
innodb_flush_logs_at_trx_commit # Flush every log write
innodb_support_xa=1             # MySQL 5.0 and newer only
innodb_safe_binlog              # MySQL 4.1 only, roughly enquivalent to
                                # innodb_support_xa
```

给二进制日志命名：

```
log_bin=/var/lib/mysql/mysql-bin # Good; specifies a path and base name
#log_bin                         # Bad; base name will be server's hostname
```

在备库上，我们同样推荐开启如下配置选项，为中继日志指定绝对路径:

```
relay_log=/path/to/logs/relay-bin
skip_slave_start
read_only
```

通过配置relay_log可以避免中继日志文件基于机器名来命名。防止之前提到的可能在主库发生的问题。指定绝对路径可以避免多个MySQL版本中存在的Bug，这些Bug可能会导致中继日志在一个意料外的位置创建。skip_slave_start选项能够阻止备库在崩g溃后自动启动复制。

read_only可以阻止大部分用户更改非临时表。

如果正在使用MySQL5.5并且不介意额外的fsync()导致的性能开销，最好设置以下选项：

```
sync_master_info    = 1
sync_relay_log      = 1
sync_relay_log_info = 1
```

MySQL复制基于主服务器在二进制日志中**跟踪所有对数据库的更改**。因此，要进行复制，必须在主服务器上启用二进制日志。思考一下，如果我要对运行中的数据库做拷贝。改怎么办？生产服务器上的数据每时每刻都是在变的。如果从我拷贝的那一刻起，我启用二进制日志，这时，二进制日志文件就开始记录客户端对数据库的操作；当我成功把数据拷贝到从服务器时，我再把二进制日志文件也拷贝过来，通过这个二进制日志文件来重新执行二进制日志当中的新的操作的SQL语句。

还有就是，每当我执行`flush logs;` 的时候，系统就会新增一个二进制日志文件。

二进制日志只是一个从启用二进制日志的固定时间点开始的记录。任何设置的从服务器需要主服务器上的在主服务器上启用二进制日志时的数据库拷贝。

### 基于语句的复制

基于语句的复制模式下，主库会记录那些造成数据更改的 *查询*，当备库读取并重放这些事件时，实际上只是把主库上执行过的SQL再执行一遍。

### 基于行的复制

这种方式会将实际数据记录在二进制日志中。

### 基于行或基于语句：哪种更优

理论上基于行的复制模式整体上更优，并且在实际应用中也适用于大多数场景。

*基于语句的复制模式的优点：*

当主备的模式不同时，逻辑复制能够在多种情况下工作。

基于语句的方式执行复制的过程基本上是执行SQL语句。

*基于语句的复制模式的缺点：*

很多情况下通过基于语句的模式无法正确复制，几乎每一个安装的备库都会碰到一次。

如果使用触发器或存储过程，就不要使用基于语句的复制模式。除非能够清楚地确定不会遇到复制问题。

*基于行的复制模式的优点：*

几乎没有基于行的复制模式无法处理的场景。

这种方式可能减少锁的使用，因为它并不要求这种强串行化是可重复的。

基于行的复制模式会记录数据变更，因此在二进制日志中记录的都是实际上在主库上发生了变化的数据。

占用更少的CPU。

能够解决数据不一致的问题。

*基于行的复制模式的缺点：*

由于执行基于行的复制的过程不可见，并且没有很好的文档和解释，因此出现问题很难找到问题的所在。

### 复制文件

复制文件会使用到的一些文件。除了二进制日志文件和中继日志文件外，还有其他文件会被用到。

那些其他文件可能在data目录或包含服务器.pid文件的目录下

*mysql-bin.index*

用于记录磁盘上的二进制日志文件。这个文件的每一行包含了二进制文件的文件名。

*mysql-relay-bin-index*

这个文件是中继日志的索引文件，和mysql-bin.index的作用类似

*relay-log.info*

这个文件包含了当前备库复制的二进制日志和中继日志坐标（例如备库复制在主库上的位置。）

删除二进制日志：

```
PURGE BINARY LOGS TO 'mysql-bin.000001';
PURGE BINARY LOGS BEFORE '2008-04-02 22:46:26';
```

最好能够显式地执行一些日志清理策略，比如设置expire_logs_days参数或其他方式。否则MySQL的二进制日志可能会将磁盘撑满。

### 发送复制事件到其他备库

`log_slave_updates`选项可以让备库变成其他服务器的主库。在设置改选项后，MySQL会将其执行过的事件记录到它自己的二进制日志中，这样它的备库就可以从其日志中检索并执行事件。

### 复制过滤器

复制过滤选项允许你仅复制服务器上的一部分数据。

两种复制过滤的方式：

1. 在主库上过滤记录到二进制日志中的事件。
2. 在备库上过滤记录到中继日志的事件。

用binlog_do_db和binlog_ignore_db来控制过滤。

二进制日志包括一组存储实际内容的二进制日志文件和一个二进制日志索引文件，而二进制索引文件包含所有使用的二进制日志文件的文件名，它用来跟踪存在的二进制日志文件。

*二进制日志文件的结构*

二进制日志文件由二进制日志索引文件，二进制日志文件，当前活动二进制日志文件组成。

活动二进制日志文件(active binlog file)，即当前正在被写入的文件。

每个二进制日志文件都以格式描述事件(format description event)开始，以日志轮换事件(rotate event)结束

格式描述日志事件包括产生该文件的服务器版本号，服务器信息及二进制日志信息等。日志轮换事件包含下一个二进制日志文件的名称，以告知二进制日志继续写入哪个文件。

如果MySQL服务器崩溃了，那么会检测二进制日志文件的写入标记，如果有这个代表写入的标记，说明二进制日志没有关闭。如果没有这个代表写入的标记，说明二进制日志文件已经关闭。

用`SHOW MASTER STATUS\G`查看当前正在写入的是哪个二进制日志文件。

停止并重置SLAVE
```
STOP SLAVE;
RESET SLAVE;
```

删除标，然后重置Master刷新：
```
DROP TABLE tbl;
RESET MASTER;
```

RESET MASTER 命令删除了所有二进制日志文件并清空了二进制索引文件。
RESET SLAVE 命令删除了Slave复制所用的所有文件。

无论是RESET MASTER 还是RESET SLAVE 都是运行复制时有效。因此：

- 执行RESET MASTER 命令时，确保没有Slave连接到该Master
- 执行RESET SLAVE 命令时，先执行STOP SLAVE命令，确保Slave上没有活动的复制

*可以用Python来管理复制，恩，想想很酷！*

基本思想是建立一个服务器如何连接到计算机（任何计算机，比如笔记本）的模型，并设计程序库，通过改变模型来管理连接。

引导Slave：

CHANGE MASTER TO 有两个有用的参数：`MASTER_LOG_FILE`和`MASTER_LOG_POS`。使用这些参数指定Master开始发送事件的binlog位置，而不是从头开始。
